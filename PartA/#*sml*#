Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
second_lecture.sml:11.7 Error: syntax error: replacing  BAR with  OP

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
second_lecture.sml:11.7 Error: syntax error: replacing  BAR with  OP

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
second_lecture.sml:11.7 Error: syntax error: replacing  BAR with  OP

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:21.38-21.43 Error: operator and opeand don't agree [tycon mismatch]
  operator domain: int * int
  operand:         int * int option
  in expression:
    i > m
second_lecture.sml:23.24-23.44 Error: operator and operand don't agree [overload conflict]
  operator domain: [~ ty]
  operand:         exp * int option -> 'Z
  in expression:
    ~ cur_max_fun
second_lecture.sml:20.6-29.55 Error: types of rules don't agree [overload conflict]
  earlier rule(s): exp -> int option
  this rule: exp -> [> ty]
  in rule:
    Add (e1,e2) =>
      if cur_max_fun (<exp>,<exp>) > cur_max_fun (<exp>,<exp>)
      then cur_max_fun (e1,m)
      else cur_max_fun (e2,m)
second_lecture.sml:29.16-29.55 Error: operator is not a function [overload conflict]
  operator: [> ty]
  in expression:
    (cur_max_fun (e2,m)) (eval e1)
second_lecture.sml:20.6-29.55 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): exp -> int option
  this rule: exp -> int
  in rule:
    Multiply (e1,e2) =>
      if cur_max_fun (<exp>,<exp>) > cur_max_fun (<exp>,<exp>)
      then cur_max_fun (e1,m)
      else (cur_max_fun <exp>) (eval <exp>) + eval e2
second_lecture.sml:19.13-29.55 Error: right-hand-side of clause doesn't agree with function result type [tycon mismatch]
  expression:  int option
  result type:  int
  in declaration:
    cur_max_fun =
      (fn (<pat> : exp,<pat> : int option) =>
            (case e
              of <pat> => <exp>
               | <pat> => <exp>
               | <pat> => <exp>
               | <pat> => <exp>))

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:21.42-21.46 Error: unbound variable or constructor: Some
second_lecture.sml:23.24-23.44 Error: operator and operand don't agree [overload conflict]
  operator domain: [~ ty]
  operand:         exp * int option -> 'Z
  in expression:
    ~ cur_max_fun
second_lecture.sml:20.6-29.55 Error: types of rules don't agree [overload conflict]
  earlier rule(s): exp -> int option
  this rule: exp -> [> ty]
  in rule:
    Add (e1,e2) =>
      if cur_max_fun (<exp>,<exp>) > cur_max_fun (<exp>,<exp>)
      then cur_max_fun (e1,m)
      else cur_max_fun (e2,m)
second_lecture.sml:29.16-29.55 Error: operator is not a function [overload conflict]
  operator: [> ty]
  in expression:
    (cur_max_fun (e2,m)) (eval e1)
second_lecture.sml:20.6-29.55 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): exp -> int option
  this rule: exp -> int
  in rule:
    Multiply (e1,e2) =>
      if cur_max_fun (<exp>,<exp>) > cur_max_fun (<exp>,<exp>)
      then cur_max_fun (e1,m)
      else (cur_max_fun <exp>) (eval <exp>) + eval e2
second_lecture.sml:19.13-29.55 Error: right-hand-side of clause doesn't agree with function result type [tycon mismatch]
  expression:  int option
  result type:  int
  in declaration:
    cur_max_fun =
      (fn (<pat> : exp,<pat> : int option) =>
            (case e
              of <pat> => <exp>
               | <pat> => <exp>
               | <pat> => <exp>
               | <pat> => <exp>))

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:21.38-21.48 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int * int
  operand:         int * int option option
  in expression:
    i > SOME m
second_lecture.sml:23.24-23.44 Error: operator and operand don't agree [overload conflict]
  operator domain: [~ ty]
  operand:         exp * int option -> 'Z
  in expression:
    ~ cur_max_fun
second_lecture.sml:20.6-29.55 Error: types of rules don't agree [overload conflict]
  earlier rule(s): exp -> int option
  this rule: exp -> [> ty]
  in rule:
    Add (e1,e2) =>
      if cur_max_fun (<exp>,<exp>) > cur_max_fun (<exp>,<exp>)
      then cur_max_fun (e1,m)
      else cur_max_fun (e2,m)
second_lecture.sml:29.16-29.55 Error: operator is not a function [overload conflict]
  operator: [> ty]
  in expression:
    (cur_max_fun (e2,m)) (eval e1)
second_lecture.sml:20.6-29.55 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): exp -> int option
  this rule: exp -> int
  in rule:
    Multiply (e1,e2) =>
      if cur_max_fun (<exp>,<exp>) > cur_max_fun (<exp>,<exp>)
      then cur_max_fun (e1,m)
      else (cur_max_fun <exp>) (eval <exp>) + eval e2
second_lecture.sml:19.13-29.55 Error: right-hand-side of clause doesn't agree with function result type [tycon mismatch]
  expression:  int option
  result type:  int
  in declaration:
    cur_max_fun =
      (fn (<pat> : exp,<pat> : int option) =>
            (case e
              of <pat> => <exp>
               | <pat> => <exp>
               | <pat> => <exp>
               | <pat> => <exp>))

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:23.24-23.44 Error: operator and operand don't agree [overload conflict]
  operator domain: [~ ty]
  operand:         exp * int option -> 'Z
  in expression:
    ~ cur_max_fun
second_lecture.sml:20.6-29.55 Error: types of rules don't agree [overload conflict]
  earlier rule(s): exp -> int option
  this rule: exp -> [> ty]
  in rule:
    Add (e1,e2) =>
      if cur_max_fun (<exp>,<exp>) > cur_max_fun (<exp>,<exp>)
      then cur_max_fun (e1,m)
      else cur_max_fun (e2,m)
second_lecture.sml:29.16-29.55 Error: operator is not a function [overload conflict]
  operator: [> ty]
  in expression:
    (cur_max_fun (e2,m)) (eval e1)
second_lecture.sml:20.6-29.55 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): exp -> int option
  this rule: exp -> int
  in rule:
    Multiply (e1,e2) =>
      if cur_max_fun (<exp>,<exp>) > cur_max_fun (<exp>,<exp>)
      then cur_max_fun (e1,m)
      else (cur_max_fun <exp>) (eval <exp>) + eval e2
second_lecture.sml:19.13-29.55 Error: right-hand-side of clause doesn't agree with function result type [tycon mismatch]
  expression:  int option
  result type:  int
  in declaration:
    cur_max_fun =
      (fn (<pat> : exp,<pat> : int option) =>
            (case e
              of <pat> => <exp>
               | <pat> => <exp>
               | <pat> => <exp>
               | <pat> => <exp>))

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:23.24-23.0 Error: operator and operand don't agree [overload conflict]
  operator domain: [~ ty]
  operand:         'Z option -> 'Z
  in expression:
    ~ valOf
second_lecture.sml:24.25-26.40 Error: operator and operand don't agree [tycon mismatch]
  operator domain: 'Z option
  operand:         exp * int option -> _
  in expression:
    valOf cur_max_fun
second_lecture.sml:24.25-26.40 Error: operator and operand don't agree [tycon mismatch]
  operator domain: 'Z option
  operand:         exp * int option -> _
  in expression:
    valOf cur_max_fun
second_lecture.sml:25.16-25.40 Error: operator and operand don't agree [tycon mismatch]
  operator domain: 'Z option
  operand:         exp * int option -> _
  in expression:
    valOf cur_max_fun
second_lecture.sml:26.16-26.40 Error: operator and operand don't agree [tycon mismatch]
  operator domain: 'Z option
  operand:         exp * int option -> _
  in expression:
    valOf cur_max_fun
second_lecture.sml:27.31-29.61 Error: operator and operand don't agree [tycon mismatch]
  operator domain: 'Z option
  operand:         exp * int option -> _
  in expression:
    valOf cur_max_fun
second_lecture.sml:27.31-29.61 Error: operator and operand don't agree [tycon mismatch]
  operator domain: 'Z option
  operand:         exp * int option -> _
  in expression:
    valOf cur_max_fun
second_lecture.sml:28.16-28.40 Error: operator and operand don't agree [tycon mismatch]
  operator domain: 'Z option
  operand:         exp * int option -> _
  in expression:
    valOf cur_max_fun
second_lecture.sml:29.16-29.61 Error: operator and operand don't agree [tycon mismatch]
  operator domain: 'Z option
  operand:         exp * int option -> _
  in expression:
    valOf cur_max_fun

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:20.30-20.41 Error: unbound variable or constructor: cur_max_fun
second_lecture.sml:20.46 Error: unbound variable or constructor: m
second_lecture.sml:20.42-20.44 Error: unbound variable or constructor: e2
second_lecture.sml:20.9-20.20 Error: unbound variable or constructor: cur_max_fun
second_lecture.sml:20.25 Error: unbound variable or constructor: m
second_lecture.sml:20.21-20.23 Error: unbound variable or constructor: e1
second_lecture.sml:21.11-21.22 Error: unbound variable or constructor: cur_max_fun
second_lecture.sml:21.27 Error: unbound variable or constructor: m
second_lecture.sml:21.23-21.25 Error: unbound variable or constructor: e1
second_lecture.sml:22.11-22.22 Error: unbound variable or constructor: cur_max_fun
second_lecture.sml:22.27 Error: unbound variable or constructor: m
second_lecture.sml:22.23-22.25 Error: unbound variable or constructor: e2
second_lecture.sml:27.26-27.37 Error: unbound variable or constructor: cur_max_fun
second_lecture.sml:27.42 Error: unbound variable or constructor: m
second_lecture.sml:25.27 Error: unbound variable or constructor: m
second_lecture.sml:25.48 Error: unbound variable or constructor: m
second_lecture.sml:26.15 Error: unbound variable or constructor: m
second_lecture.sml:27.24-27.44 Error: operator is not a function [overload conflict]
  operator: [~ ty]
  in expression:
    (~ <errorvar>) (e2,<errorvar>)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:20.25-20.27 Error: unbound variable or constructor: e1
second_lecture.sml:21.18-21.20 Error: unbound variable or constructor: e2
second_lecture.sml:30.24-30.33 Error: operator and operand don't agree [overload conflict]
  operator domain: [~ ty]
  operand:         exp -> [> ty]
  in expression:
    ~ max

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:30.24-30.33 Error: operator and operand don't agree [overload conflict]
  operator domain: [~ ty]
  operand:         exp -> [> ty]
  in expression:
    ~ max

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:30.24-30.33 Error: operator and operand don't agree [overload conflict]
  operator domain: [~ ty]
  operand:         exp -> [> ty]
  in expression:
    ~ max

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
val max = fn : exp -> int
val it = () : unit
- max x;
val it = 19 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
val max = fn : exp -> int
val it = () : unit
- max x;
val it = 19 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
val max = fn : exp -> int
val st = fn : int * int * int -> int
val st = fn : int * int -> int
val it = () : unit
- st (1,2,3);
stdIn:2.1-2.11 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int * int
  operand:         [int ty] * [int ty] * [int ty]
  in expression:
    st (1,2,3)
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
val max = fn : exp -> int
val st = fn : int * int * int -> int
val st = fn : 'a * 'b -> 'a * 'b
val it = () : unit
- st (1,2);
val it = (1,2) : int * int
- st;
val it = fn : 'a * 'b -> 'a * 'b
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
val max = fn : exp -> int
val st = fn : int * int * int -> int
val st = fn : 'a * 'b -> 'a * 'b
second_lecture.sml:36.20-36.40 Error: unbound variable or constructor: ListLengthExpression

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
val max = fn : exp -> int
val st = fn : int * int * int -> int
val st = fn : 'a * 'b -> 'a * 'b
second_lecture.sml:36.20-36.38 Error: unbound variable or constructor: ListLengthMismatch

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
val max = fn : exp -> int
val st = fn : int * int * int -> int
val st = fn : 'a * 'b -> 'a * 'b
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val it = () : unit
- zip3([1,2,3],[a,b,c],[5,6,7]);
stdIn:2.19 Error: unbound variable or constructor: c
stdIn:2.17 Error: unbound variable or constructor: b
stdIn:2.15 Error: unbound variable or constructor: a
- zip3([1,2,3],["a","b","c"],[5,6,7]);
val it = [(1,"a",5),(2,"b",6),(3,"c",7)] : (int * string * int) list
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
al x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
val max = fn : exp -> int
val st = fn : int * int * int -> int
val st = fn : 'a * 'b -> 'a * 'b
second_lecture.sml:43.24-43.2 Error: unbound type constructor: tl3
second_lecture.sml:39.5-44.13 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): 'Z list * 'Y list * 'X list -> 'W list
  this rule: ('V * 'U * [E]) list -> 'V list * 'U list * [E]
  in rule:
    :: ((a,b,c),tl) =>
      let val (<pat>,<pat>,<pat>) = zip3rev <exp>
      in (a :: tl1,b :: tl2,c: [E])
      end
second_lecture.sml:39.5-44.13 Error: case object and rules don't agree [tycon mismatch]
  rule domain: 'Z list * 'Y list * 'X list
  object: ('W * 'V * [E]) list
  in expression:
    (case thing
      of (nil,nil,nil) => nil
       | :: ((<pat>,<pat>,<pat>),tl) =>
           let val <pat> = <exp> in (<exp> :: <exp>,<exp> :: <exp>,c: [E]) end)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- euse "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
val max = fn : exp -> int
val st = fn : int * int * int -> int
val st = fn : 'a * 'b -> 'a * 'b
second_lecture.sml:39.5-44.13 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): 'Z list * 'Y list * 'X list -> 'W list
  this rule: ('V * 'U * 'T) list -> 'V list * 'U list * 'T list
  in rule:
    :: ((a,b,c),tl) =>
      let val (<pat>,<pat>,<pat>) = zip3rev <exp>
      in (a :: tl1,b :: tl2,c :: tl3)
      end
second_lecture.sml:39.5-44.13 Error: case object and rules don't agree [tycon mismatch]
  rule domain: 'Z list * 'Y list * 'X list
  object: ('W * 'V * 'U) list
  in expression:
    (case thing
      of (nil,nil,nil) => nil
       | :: ((<pat>,<pat>,<pat>),tl) =>
           let val <pat> = <exp>
           in (<exp> :: <exp>,<exp> :: <exp>,<exp> :: <exp>)
           end)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
val max = fn : exp -> int
val st = fn : int * int * int -> int
val st = fn : 'a * 'b -> 'a * 'b
second_lecture.sml:39.5-44.1 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): 'Z list * 'Y list * 'X list -> unit
  this rule: ('W * 'V * 'U) list -> 'W list * 'V list * 'U list
  in rule:
    :: ((a,b,c),tl) =>
      let val (<pat>,<pat>,<pat>) = zip3rev <exp>
      in (a :: tl1,b :: tl2,c :: tl3)
      end
second_lecture.sml:39.5-44.13 Error: case object and rules don't agree [tycon mismatch]
  rule domain: 'Z list * 'Y list * 'X list
  object: ('W * 'V * 'U) list
  in expression:
    (case thing
      of (nil,nil,nil) => ()
       | :: ((<pat>,<pat>,<pat>),tl) =>
           let val <pat> = <exp>
           in (<exp> :: <exp>,<exp> :: <exp>,<exp> :: <exp>)
           end)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
val max = fn : exp -> int
val st = fn : int * int * int -> int
val st = fn : 'a * 'b -> 'a * 'b
second_lecture.sml:39.5-44.13 rror: types of rules don't agree [tycon mismatch]
  earlier rule(s): unit list -> unit
  this rule: ('Z * 'Y * 'X) list -> 'Z list * 'Y list * 'X list
  in rule:
    :: ((a,b,c),tl) =>
      let val (<pat>,<pat>,<pat>) = zip3rev <exp>
      in (a :: tl1,b :: tl2,c :: tl3)
      end
second_lecture.sml:39.5-44.13 Error: case object and rules don't agree [tycon mismatch]
  rule domain: unit list
  object: ('Z * 'Y * 'X) list
  in expression:
    (case thing
      of () :: () :: <pat> :: <pat> => ()
       | :: ((<pat>,<pat>,<pat>),tl) =>
           let val <pat> = <exp>
           in (<exp> :: <exp>,<exp> :: <exp>,<exp> :: <exp>)
           end)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
val max = fn : exp -> int
val st = fn : int * int * int -> int
val st = fn : 'a * 'b -> 'a * 'b
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val it = () : unit
- zip3([1,2,3],["a","b","c"],[5,6,7]);
val it = [(1,"a",5),(2,"b",6),(3,"c",7)] : (int * string * int) list
- zip3rev(zip3([1,2,3],["a","b","c"],[5,6,7]));
val it = ([1,2,3],["a","b","c"],[5,6,7]) : int list * string list * int list
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
val max = fn : exp -> int
val st = fn : int * int * int -> int
val st = fn : 'a * 'b -> 'a * 'b
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
val it = () : unit
- nondec [3,4,5,6];
val it = true : bool
- nondec [3,4,5,2];
val it = false : bool
- nondec [];
val it = true : bool
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
val max = fn : exp -> int
val st = fn : int * int * int -> int
val st = fn : 'a * 'b -> 'a * 'b
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
val it = () : unit
- zip3rev(zip3([1,2,3],["a","b","c"],[5,6,7]));
val it = ([1,2,3],["a","b","c"],[5,6,7]) : int list * string list * int list
- nondec [];
val it = true : bool
- nondec [3,4,5,2];
val it = false : bool
- nondec [3,4,5,2];
val it = false : bool
- nondec [3,4,5,6];
val it = true : bool
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
val max = fn : exp -> int
val st = fn : int * int * int -> int
val st = fn : 'a * 'b -> 'a * 'b
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
second_lecture.sml:55.10 Error: unbound variable or constructor: e

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
val max = fn : exp -> int
val st = fn : int * int * int -> int
val st = fn : 'a * 'b -> 'a * 'b
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
second_lecture.sml:55.5-60.19 Warning: match nonexhaustive
          (_,Z) => ...
          (Z,_) => ...
          (P,N) => ...
          (N,P) => ...
          (P,P) => ...
  
val multsign = fn : sgn * sgn -> sgn
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
val max = fn : exp -> int
val st = fn : int * int * int -> int
val st = fn : 'a * 'b -> 'a * 'b
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val it = () : uni
- multsign(P,N);
val it = N : sgn
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
val max = fn : exp -> int
val st = fn : int * int * int -> int
val st = fn : 'a * 'b -> 'a * 'b
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val it = () : unit
- multsign(P,N);
val it = N : sgn
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:30.15-30.17 Error: syntax error: replacing  DARROW with  EQUALOP

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:29.5-30.22 Error: parameter or result constraints of clauses don't agree [tycon mismatch]
  this clause:      'Z * 'Y -> 'X
  previous clauses:      'W * 'V * 'U -> 'X
  in declaration:
    st = (fn (x,y,z) => <exp> + <exp> + z
           | (x,y) => x + y)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:30.5-30.7 Error: can't find function arguments in clause
second_lecture.sml:30.31 Error: unbound variable or constructor: z
second_lecture.sml:30.27 Error: unbound variable or constructor: y
second_lecture.sml:30.18 Error: unbound variable or constructor: z
second_lecture.sml:30.15 Error: unbound variable or constructor: y
second_lecture.sml:30.11-30.32 Error: operator and operand don't agree [overload conflict]
  operator domain: [+ ty] * [+ ty]
  operand:         exp * _
  in expression:
    x + <errorvar>
second_lecture.sml:30.11-30.32 Error: operator and operand don't agree [overload conflict]
  operator domain: (exp * _ * _) * (exp * _ * _)
  operand:         (exp * _ * _) * [+ ty]
  in expression:
    (x,<errorvar>,<errorvar>) = x + <errorvar> + <errorvar>

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:30.5-30.14 Error: syntax error: deleting  CASE ID OF

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:30.5-32.29 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): [+ ty] * [+ ty] -> [+ ty]
  this rule: [+ ty] * [+ ty] * [+ ty] -> [+ ty]
  in rule:
    (x,y,z) => x + y + z

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:30.5-32.29 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): [+ ty] * [+ ty] -> [+ ty]
  this rule: [+ ty] * [+ ty] * [+ ty] -> [+ ty]
  in rule:
    (x,y,z) => x + y + z

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:30.5-32.29 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): [+ ty] * [+ ty] -> [+ ty]
  this rule: [+ ty] * [+ ty] * [+ ty] -> [+ ty]
  in rule:
    (x,y,z) => x + y + z

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
second_lecture.sml:67.23-67.39 Error:operator and operand don't agree [circularity]
  operator domain: 'Z * 'Z list
  operand:         'Z * 'Z
  in expression:
    y :: x

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
second_lecture.sml:65.28-65.44 Error: operator and operand don't agree [tycon mismatch]
  operator domain: 'Z * 'Y
  operand:         'X list
  in expression:
    append xs'
second_lecture.sml:65.25-65.44 Error: operator and operand don't agree [tycon mismatch]
  operator domain: 'Z * 'Z list
  operand:         'Z * (_ * 'Y)
  in expression:
    x :: (append xs',ys')

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val it = () : unit
- append([1,3,4],[3,2,8]);
val it = [1,3,4,3,2,8] : int list
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
second_lecture.sml:71.9-71.46 Error: operator and operand don't agree [circularity]
  operator domain: 'Z * 'Z list
  operand:         'Z * 'Z
  in expression:
    y :: x

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
second_lecture.sml:71.42-71.46 Error: operator ad operand don't agree [circularity]
  operator domain: 'Z * 'Z list
  operand:         'Z * 'Z
  in expression:
    y :: x

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
second_lecture.sml:68.5-71.52 Warning: match nonexhaustive
          nil => ...
          x :: y :: nil => ...
          x :: y :: rest => ...
  
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val it = () : unit
- rev [1,2,3,6,5,8];
val it = [8,5,6,3,2,1] : int list
cs 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val it = () : unit
- rev [1,2,3,6,5,8];
val it = [8,5,6,3,2,1] : int list
- 

Process sml finished
csStandard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
second_lecture.sml:73.9 Error: syntax error: inserting  VALee

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
val it = () : unit
- rrev [1,2,3,6,5,8];
val it = [8,5,6,3,2,1] : int list
- [1,2,3] @ [4,5,6];
val it = [1,2,3,4,5,6] : int list
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
second_lecture.sml:81.1-81.9 Error: syntax error: replacing  DATATYPE with  AND
second_lecture.sml:81.44-83.4 Error: syntax error:deleting  SEMICOLON VAL

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
second_lecture.sml:81.10-81.12 Error: syntax error: replacing  ID with  LAZY

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | List of 'a * 'a mylist
val ml = (5,Empty) : int * 'a mylist
val ml2 = (5,4,Empty) : int * int * 'a mylist
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
second_lecture.sml:85.5-85.28 Error: operator and operand don't agree [tycon mismatch]
  operator domain: 'Z * 'Z mylist
  operand:         [int ty] * [int ty] * 'Y mylist
  in expression:
    Value (5,4,Empty)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
second_lecture.sml:85.5-85.30 Error: operator and operand don't agree [tycon mismatch]
  operator domain: [int ty] * [int ty] mylist
  operand:         [int ty] * ([int ty] * 'Z mylist)
  in expression:
    Value (5,(4,Empty))

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val it = () : unit
- pass_fail {id = 5, grade = Some 80};
stdIn:2.28-2.32 Error: unbound variable or constructor: Some
- pass_fail {id = 5, grade = SOME 80};
val it = pass : pass_fail
- pass_fail {id = 5, grade = SOME 74};
val it = fail : pass_fail
- pass_fail {id = 5, grade = NONE};
val it = fail : pass_fail
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val it = () : unit
- has_p {id = 5, grade = NONE};
val it = false : bool
- has_p {id = 5, grade = SOME 74};
val it = false : bool
- has_p {id = 5, grade = SOME 80};
val it = true : bool
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val it = () : unit
- num_p lofg;
val it = 2 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (fail,{grade=SOME 40,id=5}),(fail,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
second_lecture.sml:118.5-118.13 Error: non-constructor applied to argument in pattern: num_m
second_lecture.sml:119.10-119.12 Error: unbound variable or constructor: xs
second_lecture.sml:122.18-122.23 Error: unbound variable or constructor: num_m
second_lecture.sml:123.14-123.19 Error: unbound variable or constructor: num_m

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (fail,{grade=SOME 40,id=5}),(fail,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
val it = () : unit
- num_m mis;
val it = 2 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(fail,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
val it = () : unit
- num_m mis;
val it = 1 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(fail,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
val it = () : unit
- num_m mis;
val it = 3 : int
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
val it = () : unit
- num_m mis;
val it = 2 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = leave_me_alone | prune_me
val t1 = leaf : 'a tree
val t2 = node {left=leaf,right=node {left=node #,right=leaf,value=7},value=2}
  : int tree
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = leave_me_alone | prune_me
val t1 = leaf : 'a tree
val t2 = node {left=leaf,right=node {left=node #,right=leaf,value=7},value=2}
  : int tree
val tree_h = fn : 'a tree -> int
val it = () : unit
- tree_h t1;
val it = 0 : int
- tree_h t2;
val it = 3 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = leave_me_alone | prune_me
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=7},value=2}
  : int tree
val tree_h = fn : 'a tree -> int
val it = () : unit
- tree_h t2;
val it = 5 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = leave_me_alone | prune_me
val t1 = leaf : 'a tree
second_lecture.sml:145.41-145.73 Error: operator and operand don't agree [oerload conflict]
  operator domain: int * int
  operand:         [+ ty]
  in expression:
    Int.max (tree_h b + tree_h c)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = leave_me_alone | prune_me
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=7},value=2}
  : int tree
val tree_h = fn : 'a tree -> int
val it = () : unit
- tree_h t2;
val it = 4 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = leave_me_alone | prune_me
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=7},value=2}
  : int tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val it = () : unit
- tree_sum t2;
val it = 48 : int
- tree_sum t1;
val it = 0 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
second_lecture.sml:155.7 Error: syntax error: replacing  BAR with  OP

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val it = () : unit
- garden t1;
val it = leaf : flag tree
- garden t2;
val it =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val it = () : unit
- garden t2;
val it =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- garden t2;
stdIn:1.2-1.8 Error: unbound variable r constructor: garden
stdIn:1.9-1.11 Error: unbound variable or constructor: t2
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val it = () : unit
- garden t2;
val it =
  node {left=leaf,right=node {left=node #,right=leaf,value=lma},value=lma}
  : flag tree
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=pm},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val it = () : unit
- garden t2;
val it = node {left=leaf,right=leaf,value=lma} : flag tree
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val it = () : unit
- garden t2;
val it =
  node {left=leaf,right=node {left=leaf,right=leaf,value=lma},value=lma}
  : flag tree

- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : 'a list list -> 'a list
val it = () : unit
- mylast [54327,32454,234,65,2];
stdIn:5.1-5.30 Error: operator and operand don't agree [overload conflict]
  operator domain: 'Z list list
  operand:         [int ty] list
  in expression:
    mylast (54327 :: 32454 :: 234 :: <exp> :: <exp>)
- mylast [3,2,5];
stdIn:1.2-1.16 Error: operator and operand don't agree [overload conflict]
  operator domain: 'Z list list
  operand:         [int ty] list
  in expression:
    mylast (3 :: 2 :: 5 :: nil)
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : ('a list -> bool) list -> 'a list -> bool
val it = () : unit
- mylast [3,2,5];
stdIn:2.1-2.15 Error: operator andoperand don't agree [overload conflict]
  operator domain: ('Z list -> bool) list
  operand:         [int ty] list
  in expression:
    mylast (3 :: 2 :: 5 :: nil)
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
second_lecture.sml:161.14-161.19 Error: argument of raise is not an exception [tycon mismatch]
  raised: 'Z mylist
  in expression:
    raise Empty

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val it = () : unit
- mylast [54327,32454,234,65,2];
val it = 2 : int
- mylast [3,2,5];
val it = 5 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
second_lecture.sml:166.9 Error: synta error: inserting  VAL

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,99] : int list
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,99] : int list
val it = [99] : int list
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,99] : int list
val it = [99] : int list
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,99] : int list
val it = [99] : int list
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,99] : int list
val it = [99] : int list
val it = () : unit
- d
= ;
stdIn:2.1 Error: unbound variable or constructor: d
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
second_lecture.sml:186.23-188.20 Error: operator is not a function [circularity]
  operator: 'Z
  in expression:
    (mydrop (xs',i - 1)) mydrop

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- myconcat [];
stdIn:1.2-1.10 Error: unbound variable or constructor: myconcat
- myconcat [];
stdIn:1.2-1.10 Error: unbound variable or constructor: myconcat
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- myconcat [];
stdIn:1.2-1.10 Error: unbound variable or constructor: myconcat
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
second_lecture.sml:197.10-197.12 Error: unbound type constructor: xs
second_lecture.sml:197.29-197.31 Error: unbound variable or constructor: xs

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
val it = () : unit
- myconcat [];
stdIn:2.1-2.12 Warning: type vars not generalized because of
   value restriction are instantiated to dummy types (X1,X2,...)
val it = [] : ?.X1 list
- myconcat [[1,2,3],[4,5,6],[7,8,9]];
val it = [1,2,3,4,5,6,7,8,9] : int list
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
second_lecture.sml:200.-202.18 Error: match redundant
          ZERO => ...
    -->   _ => ...
  

uncaught exception Error
  raised at: ../compiler/FLINT/trans/translate.sml:1735.13-1735.21
             ../compiler/Basics/stats/stats.sml:198.40
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
second_lecture.sml:200.5-202.18 Error: match redundant
          ZERO => ...
    -->   n => ...
  

uncaught exception Error
  raised at: ../compiler/FLINT/trans/translate.sml:1735.13-1735.21
             ../compiler/Basics/stats/stats.sml:198.40
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
second_lecture.sml:207.1-207.14 Eror: operator and operand don't agree [tycon mismatch]
  operator domain: nat
  operand:         nat -> nat
  in expression:
    pos SUCC

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
val it = () : unit
- use "second_lecture.sml"
= ;
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml"	(*  *)
= ;
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negativie
second_lecture.sml:215.16-215.24 Error: unbound variable or constructor: Negative
second_lecture.sml:214.5-216.19 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): nat -> 'Z
  this rule: 'Y list -> 'Y list
  in rule:
    :: (x,xs) => xs

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negativie
second_lecture.sml:215.16-215.21 Error: argument of raise is not an exception [tycon mismatch]
  raised: 'Z mylist
  in expression:
    raise Empty
second_lecture.sml:214.5-216.19 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): nat -> 'Z
  this rule: 'Y list -> 'Y list
  in rule:
    :: (x,xs) => xs

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negativie
second_lecture.sml:215.16-215.25 Error: unbound variable or constructor: EmptyList
second_lecture.sml:214.5-216.19 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): nat -> 'Z
  this rule: 'Y list -> 'Y list
  in rule:
    :: (x,xs) => xs

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
second_lecture.sml:211.20-211.31 Error: syntax error: deleting  STRING SEMICOLON

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
second_lecture.sml:211.20-211.30 Error: syntx error: deleting  STRING

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
second_lecture.sml:214.5-216.19 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): nat -> 'Z
  this rule: 'Y list -> 'Y list
  in rule:
    :: (x,xs) => xs

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
second_lecture.sml:216.13-216.15 Eror: syntax error: replacing  OF with  AS

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val it = () : unit
- pred ZERO;

uncaught exception Negative
  raised at: second_lecture.sml:215.16-215.35
- pred SUCC ZERO;
stdIn:1.2-1.16 Error: operator and operand don't agree [tycon mismatch]
  operator domain: nat
  operand:         nat -> nat
  in expression:
    pred SUCC
- pred (SUCC ZERO);
val it = ZERO : nat
- pred (SUCC (SUCC ZERO));
val it = SUCC ZERO : nat
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:224.1 Error: syntax error found at EOF

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- n3;
val it = SUCC (SUCC (SUCC ZERO)) : nat
- n2;
val it = SUCC (SUCC ZERO) : nat
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
val nat_to_int = fn : nat -> int
val it = () : unit
- nat_to_int n0;
val it = 0 : int
- nat_to_int n1;
val it = 1 : int
- nat_to_int n3;
val it = 3 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:231.7 Errr: syntax error: replacing  BAR with  AND

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:231.7 Error: syntax error: replacing  BAR with  AND

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:232.22 Error: syntax error: replacing  EQUALOP with  DARROW

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:231.21-231.34 Error: operator and oprand don't agree [circularity]
  operator domain: (''Z * nat) * (''Z * nat)
  operand:         (''Z * nat) * ''Z
  in expression:
    (n,ZERO) = n

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:231.21-231.23 Error: syntax error: replacing  DARROW with  EQUALOP

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val it = () : unit
- add (n0,n1);
val it = SUCC ZERO : nat
- add (n0,n0);
val it = ZERO : nat
- add (n1,n1);
val it = SUCC (SUCC ZERO) : nat
- add (n3,n2);
val it = SUCC (SUCC (SUCC (SUCC (SUCC #)))) : nat
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val it = () : unit
- sub (n0,n0);
val it = ZERO : nat
- sub (n0,n1);
val it = ZERO : nat
- pred n0;

uncaught exception Negative
  raised at: second_lecture.sml:215.16-215.35
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- pred n0;
stdIn:1.2-1.6 Error: unbound variable or constructor: pred
stdIn:1.7-1.9 Error: unbound variable or constructor: n0
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val it = () : unit
- sub (n0,n1);

uncaught exception Negative
  raised at: second_lecture.sml:215.16-215.35
- sub (n1,n1);
val it = ZERO : nat
- sub (n3,n1);
val it = SUCC (SUCC ZERO) : nat
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:240.5-245.39 Error: types of rules don't agree [overload conflict]
  earlier rule(s): nat * nat -> nat
  this rule: [int ty] * 'Z -> 'Z
  in rule:
    (1,s) => s
second_lecture.sml:240.5-245.39 Error: types of rules don't agree [overload conflict]
  earlier rule(s): nat * nat -> nat
  this rule: nat * [int ty] -> nat
  in rule:
    (n,1) => n

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val it = () : unit
- mult (n0,n2);
val it = ZERO : nat
- mult (n1,n2);
val it = SUCC (SUCC ZERO) : nat
- mult (n3,n2);
val it = SUCC (SUCC (SUCC (SUCC (SUCC #)))) : nat
- mult (n2,n2);
val it = SUCC (SUCC (SUCC (SUCC ZERO))) : nat
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
val it = () : unit
- less_than(n0,n0);
val it = false : bool
- less_than(n0,n1);
val it = false : bool
- less_than(n1,n1);
val it = false : bool
- less_than(n2,n1);
val it = true : bool
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
val it = () : unit
- less_than(n2,n1);
val it = false : bool
- less_than(n1,n1);
val it = true : bool
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
val it = () : unit
- less_than(n1,n1);
val it = false : bool
- less_than(n2,n1);
val it = false : bool
- less_than(n1,n1);
val it = false : bool
- less_than(n1,n3);
val it = true : bool
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:260.5-263.44 Error: typs of rules don't agree [tycon mismatch]
  earlier rule(s): 'Z list -> bool
  this rule: {from:'Y, to:'X} -> bool
  in rule:
    {from=x,to=y} => false
second_lecture.sml:260.5-263.44 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): 'Z list -> bool
  this rule: 'Y * 'Y -> bool
  in rule:
    (x,y) => (isEmpty x) orelse (isEmpty y)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:264.9 Error: on-constructor applied to argument in pattern
second_lecture.sml:264.45 Error: unbound variable or constructor: y
second_lecture.sml:260.5-264.46 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): intSet -> bool
  this rule: intSet list -> bool
  in rule:
    :: (Elems x,xs) => false
second_lecture.sml:260.5-264.46 Error: case object and rules don't agree [tycon mismatch]
  rule domain: intSet
  object: exp
  in expression:
    (case is
      of Elems nil => true
       | :: (Elems <pat>,xs) => false
       | Range {from=x,to=y} => false
       | _ => (isEmpty x) orelse (isEmpty <errorvar>))

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:260.5-265.57 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): intSet -> bool
  this rule: intSet list -> bool
  in rule:
    :: (Elems x,xs) => false

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:260.5-265.57 Error: typs of rules don't agree [tycon mismatch]
  earlier rule(s): intSet -> bool
  this rule: intSet list -> bool
  in rule:
    :: (Elems _,_) => false

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val isEmpty = fn : intSet -> bool
val it = () : unit
- isEmpty [];
stdIn:2.1-2.11 Error: operator and operand don't agree [tycon mismatch]
  operator domain: intSet
  operand:         'Z list
  in expression:
    isEmpty nil
- isEmpty (Elems []);
val it = true : bool
- isEmpty (Elems [2]);
val it = false : bool
- isEmpty (Range {from=1,to=1});
val it = false : bool
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:270.45 Error: syntax error:inserting  EQUALOP

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:263.34-263.38 Error: unbound variable or constructor: from
second_lecture.sml:263.55-263.57 Error: unbound variable or constructor: to
second_lecture.sml:259.5-263.57 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): [<= ty] list -> bool
  this rule: {from:'Z, to:'Y} -> bool
  in rule:
    {from=x,to=y} => (item >= <errorvar>) andalso (item <= <errorvar>)
second_lecture.sml:272.11-282.20 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): int list * int list * int list -> int list
  this rule: {from:int, to:int} * {from:int, to:int} * 'Z
             -> {from:int, to:int}
  in rule:
    ({from=x,to=y},{from=a,to=b},acc) =>
      let val f = Int.min <exp>
          val t = Int.max <exp> in {from=f,to=t} end
second_lecture.sml:284.16-284.29 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int list * int list * int list
  operand:         intSet * intSet * 'Z list
  in expression:
    inter (x,y,nil)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:259.5-263.53 Error: types of rules on't agree [tycon mismatch]
  earlier rule(s): [<= ty] list -> bool
  this rule: {from:[<= ty], to:[<= ty]} -> bool
  in rule:
    {from=x,to=y} => (item >= x) andalso (item <= y)
second_lecture.sml:272.11-282.20 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): int list * int list * int list -> int list
  this rule: {from:int, to:int} * {from:int, to:int} * 'Z
             -> {from:int, to:int}
  in rule:
    ({from=x,to=y},{from=a,to=b},acc) =>
      let val f = Int.min <exp>
          val t = Int.max <exp> in {from=f,to=t} end
second_lecture.sml:284.16-284.29 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int list * int list * int list
  operand:         intSet * intSet * 'Z list
  in expression:
    inter (x,y,nil)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:259.5-263.59 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): 'Z list -> bool
  this rule: intSet -> bool
  in rule:
    Elems (:: (x,xs)) => if item = x then true else mycontains (x,xs)
second_lecture.sml:259.5-263.59 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): 'Z list -> bool
  this rule: intSet -> bool
  in rule:
    Range {from=x,to=y} => (item >= x) andalso (item <= y)
second_lecture.sml:272.11-282.20 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): int list * int list * int list -> int list
  this rule: {from:int, to:int} * {from:int, to:int} * 'Z
             -> {from:int, to:int}
  in rule:
    ({from=x,to=y},{from=a,to=b},acc) =>
      let val f = Int.min <exp>
          val t = Int.max <exp> in {from=f,to=t} end
second_lecture.sml:284.16-284.29 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int list * int list * int list
  operand:         intSet * intSet * 'Z list
  in expression:
    inter (x,y,nil)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:259.5-263.61 Error: types of rles don't agree [tycon mismatch]
  earlier rule(s): 'Z list -> bool
  this rule: intSet -> bool
  in rule:
    Elems (:: (x,xs)) => if item = x then true else mycontains (x,xs)
second_lecture.sml:259.5-263.61 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): 'Z list -> bool
  this rule: intSet -> bool
  in rule:
    Range {from=x,to=y} => (item >= x) andalso (item <= y)
second_lecture.sml:272.11-282.20 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): int list * int list * int list -> int list
  this rule: {from:int, to:int} * {from:int, to:int} * 'Z
             -> {from:int, to:int}
  in rule:
    ({from=x,to=y},{from=a,to=b},acc) =>
      let val f = Int.min <exp>
          val t = Int.max <exp> in {from=f,to=t} end
second_lecture.sml:284.16-284.29 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int list * int list * int list
  operand:         intSet * intSet * 'Z list
  in expression:
    inter (x,y,nil)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:259.5-263.61 Error: case object and rules don't agree [tycon mismatch]
  rule domain: intSet
  object: int list
  in expression:
    (case lstorrange
      of Elems nil => false
       | Elems (:: (<pat>,<pat>)) =>
           if item = x then true else mycontains (<exp>,<exp>)
       | Range {from=x,to=y} => (item >= x) andalso (item <= y))
second_lecture.sml:272.11-282.20 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): int list * int list * int list -> int list
  this rule: {from:int, to:int} * {from:int, to:int} * 'Z
             -> {from:int, to:int}
  in rule:
    ({from=x,to=y},{from=a,to=b},acc) =>
      let val f = Int.min <exp>
          val t = Int.max <exp> in {from=f,to=t} end
second_lecture.sml:284.16-284.29 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int list * int list * int list
  operand:         intSet * intSet * 'Z list
  in expression:
    inter (x,y,nil)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:259.5-263.61 Error: case object and rules don't agree [tycon mismatch]
  rule domain: intSet
  object: int list
  in expression:
    (case lstorrange
      of Elems nil => false
       | Elems (:: (<pat>,<pat>)) =>
           if item = x then true else mycontains (<exp>,<exp>)
       | Range {from=x,to=y} => (item >= x) andalso (item <= y))
second_lecture.sml:272.11-282.20 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): int list * int list * int list -> int list
  this rule: {from:int, to:int} * {from:int, to:int} * 'Z
             -> {from:int, to:int}
  in rule:
    ({from=x,to=y},{from=a,to=b},acc) =>
      let val f = Int.min <exp>
          val t = Int.max <exp> in {from=f,to=t} end
second_lecture.sml:284.16-284.29 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int list * int list * int list
  operand:         intSet * intSet * 'Z list
  in expression:
    inter (x,y,nil)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:259.5-263.61 Erro: case object and rules don't agree [tycon mismatch]
  rule domain: intSet
  object: int * int list
  in expression:
    (case (item,lor)
      of Elems nil => false
       | Elems (:: (<pat>,<pat>)) =>
           if item = x then true else mycontains (<exp>,<exp>)
       | Range {from=x,to=y} => (item >= x) andalso (item <= y))
second_lecture.sml:272.11-282.20 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): int list * int list * int list -> int list
  this rule: {from:int, to:int} * {from:int, to:int} * 'Z
             -> {from:int, to:int}
  in rule:
    ({from=x,to=y},{from=a,to=b},acc) =>
      let val f = Int.min <exp>
          val t = Int.max <exp> in {from=f,to=t} end
second_lecture.sml:284.16-284.29 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int list * int list * int list
  operand:         intSet * intSet * 'Z list
  in expression:
    inter (x,y,nil)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:259.5-263.68 Error: case object and rules don't agree [tycon mismatch]
  rule domain: int * intSet
  object: int * int list
  in expression:
    (case (item,lor)
      of (item,Elems nil) => false
       | (item,Elems (:: <pat>)) =>
           if item = x then true else mycontains (<exp>,<exp>)
       | (item,Range {from=<pat>,to=<pat>}) => (item >= x) andalso (item <= y))
second_lecture.sml:272.11-282.20 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): int list * int list * int list -> int list
  this rule: {from:int, to:int} * {from:int, to:int} * 'Z
             -> {from:int, to:int}
  in rule:
    ({from=x,to=y},{from=a,to=b},acc) =>
      let val f = Int.min <exp>
          val t = Int.max <exp> in {from=f,to=t} end
second_lecture.sml:284.16-284.29 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int list * int list * int list
  operand:         intSet * intSet * 'Z list
  in expression:
    inter (x,y,nil)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:259.5-263.68 Error: case object and ules don't agree [tycon mismatch]
  rule domain: int * intSet
  object: int * int list
  in expression:
    (case (item,lor)
      of (item,Elems nil) => false
       | (item,Elems (:: <pat>)) =>
           if item = x then true else mycontains (<exp>,<exp>)
       | (item,Range {from=<pat>,to=<pat>}) => (item >= x) andalso (item <= y))
second_lecture.sml:272.11-282.20 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): int list * int list * int list -> int list
  this rule: {from:int, to:int} * {from:int, to:int} * 'Z
             -> {from:int, to:int}
  in rule:
    ({from=x,to=y},{from=a,to=b},acc) =>
      let val f = Int.min <exp>
          val t = Int.max <exp> in {from=f,to=t} end
second_lecture.sml:284.16-284.29 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int list * int list * int list
  operand:         intSet * intSet * 'Z list
  in expression:
    inter (x,y,nil)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
xception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:259.5-263.68 Error: case object and rules don't agree [tycon mismatch]
  rule domain: int * intSet
  object: int * int list
  in expression:
    (case (item,lor)
      of (item,Elems nil) => false
       | (item,Elems (:: <pat>)) =>
           if item = x then true else mycontains (<exp>,<exp>)
       | (item,Range {from=<pat>,to=<pat>}) => (item >= x) andalso (item <= y))
second_lecture.sml:272.11-282.20 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): int list * int list * int list -> int list
  this rule: {from:int, to:int} * {from:int, to:int} * 'Z
             -> {from:int, to:int}
  in rule:
    ({from=x,to=y},{from=a,to=b},acc) =>
      let val f = Int.min <exp>
          val t = Int.max <exp> in {from=f,to=t} end
second_lecture.sml:284.16-284.29 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int list * int list * int list
  operand:         intSet * intSet * 'Z list
  in expression:
    inter (x,y,nil)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:259.5-263.63 Errr: types of rules don't agree [tycon mismatch]
  earlier rule(s): [<= ty] * [<= ty] list -> bool
  this rule: [<= ty] * {from:[<= ty], to:[<= ty]} -> bool
  in rule:
    (item,{from=x,to=y}) => (item >= x) andalso (item <= y)
second_lecture.sml:272.11-282.18 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): intSet * intSet * 'Z -> 'Z
  this rule: intSet * int list * int list -> 'Y
  in rule:
    (Elems (:: (<pat>,<pat>)),y,acc) =>
      if mycontains (x',y)
      then inter (xs,y,<exp> :: <exp>)
      else inter (xs,y,acc)
second_lecture.sml:272.11-282.18 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): intSet * intSet * 'Z -> 'Z
  this rule: int list * intSet * int list -> 'Y
  in rule:
    (x,Elems (:: (<pat>,<pat>)),acc) => inter (y' :: ys,x,acc)
second_lecture.sml:272.11-282.18 Error: case object and rules don't agree [tycon mismatch]
  rule domain: intSet * intSet * {from:int, to:int}
  object: int list * int list * int list
  in expression:
    (case (x,y,acc)
      of (Elems nil,_,acc) => acc
       | (_,Elems nil,acc) => acc
       | (Elems (:: <pat>),y,acc) =>
           if mycontains (<exp>,<exp>)
           then inter (<exp>,<exp>,<exp>)
           else inter (<exp>,<exp>,<exp>)
       | (x,Elems (:: <pat>),acc) => inter (<exp> :: <exp>,x,acc)
       | (Range {from=<pat>,to=<pat>},Range {from=<pat>,to=<pat>},acc) =>
           let val <pat> = <exp>
               val <pat> = <exp> in {from=f,to=t} end)
second_lecture.sml:284.16-284.29 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int list * int list * int list
  operand:         intSet * intSet * 'Z list
  in expression:
    inter (x,y,nil)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:259.5-263.61 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): [<= ty] * [<= ty] list -> bool
  this rule: [<= ty] * {from:[<= ty], to:[<= ty]} -> bool
  in rule:
    (item,{from=x,to=y}) => (item >= x) andalso (item <= y)
second_lecture.sml:272.11-282.18 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): intSet * intSet * 'Z -> 'Z
  this rule: intSet * int list * int list -> 'Y
  in rule:
    (Elems (:: (<pat>,<pat>)),y,acc) =>
      if mycontains (x',y)
      then inter (xs,y,<exp> :: <exp>)
      else inter (xs,y,acc)
second_lecture.sml:272.11-282.18 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): intSet * intSet * 'Z -> 'Z
  this rule: int list * intSet * int list -> 'Y
  in rule:
    (x,Elems (:: (<pat>,<pat>)),acc) => inter (y' :: ys,x,acc)
second_lecture.sml:272.11-282.18 Error: case object and rules don't agree [tycon mismatch]
  rule domain: intSet * intSet * {from:int, to:int}
  object: int list * int list * int list
  in expression:
    (case (x,y,acc)
      of (Elems nil,_,acc) => acc
       | (_,Elems nil,acc) => acc
       | (Elems (:: <pat>),y,acc) =>
           if mycontains (<exp>,<exp>)
           then inter (<exp>,<exp>,<exp>)
           else inter (<exp>,<exp>,<exp>)
       | (x,Elems (:: <pat>),acc) => inter (<exp> :: <exp>,x,acc)
       | (Range {from=<pat>,to=<pat>},Range {from=<pat>,to=<pat>},acc) =>
           let val <pat> = <exp>
               val <pat> = <exp> in {from=f,to=t} end)
second_lecture.sml:284.16-284.29 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int list * int list * int list
  operand:         intSet * intSet * 'Z list
  in expression:
    inter (x,y,nil)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:259.5-263.61 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): [<= ty] * [<= ty] list -> bool
  this rule: [<= ty] * {from:[<= ty], to:[<= ty]} -> bool
  in rule:
    (item,{from=x,to=y}) => (item >= x) andalso (item <= y)
second_lecture.sml:272.11-283.18 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): intSet * intSet * int list -> intSet
  this rule: intSet * int list * int list -> 'Z
  in rule:
    (Elems (:: (<pat>,<pat>)),y,acc) =>
      if mycontains (x',y)
      then inter (xs,y,<exp> :: <exp>)
      else inter (xs,y,acc)
second_lecture.sml:272.11-283.18 Error: types of rules don't agree [tycon mismatch]
  earlier rule(s): intSet * intSet * int list -> intSet
  this rule: int list * intSet * int list -> 'Z
  in rule:
    (x,Elems (:: (<pat>,<pat>)),acc) => inter (y' :: ys,x,acc)
second_lecture.sml:272.11-283.18 Error: case object and rules don't agree [tycon mismatch]
  rule domain: intSet * intSet * int list
  object: int list * int list * int list
  in expression:
    (case (x,y,acc)
      of (Elems nil,_,acc) => Elems acc
       | (_,Elems nil,acc) => Elems acc
       | (Elems (:: <pat>),y,acc) =>
           if mycontains (<exp>,<exp>)
           then inter (<exp>,<exp>,<exp>)
           else inter (<exp>,<exp>,<exp>)
       | (x,Elems (:: <pat>),acc) => inter (<exp> :: <exp>,x,acc)
       | (Range {from=<pat>,to=<pat>},Range {from=<pat>,to=<pat>},acc) =>
           let val <pat> = <exp>
               val <pat> = <exp>
           in if <exp> <= <exp> then Range <exp> else Elems <exp>
           end)
second_lecture.sml:285.16-285.29 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int list * int list * int list
  operand:         intSet * intSet * 'Z list
  in expression:
    inter (x,y,nil)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:267.14 Error: syntax error: inserting  FN

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:266.5-269.94 Warning: match nonexhaustive
          Elems nil => ...
          Elems (x :: xs) => ...
          Range {from=x,to=y} => ...
  
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val toList = fn : intSet -> int list
val it = () : unit
- toList (Elems [3,2,6,9]);
val it = [3,2,6,9] : int list
- toList (Range {from=6, to=12});
val it = [6,7,8,9,10,11,12] : int list
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:266.5-270.43 Warning: match nonexhaustive
          Elems nil => ...
          Elems (x :: xs) => ...
          Range {from=x,to=y} => ...
          Union (x,y) => ...
  
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val toList = fn : intSet -> int list
val it = () : unit
- toList (Union (Elems [1,2,34]),(Range {from=6, to=12});
= ;
= toList (Union (Elems [1,2,34]),(Range {from=6, to=12}));
=   C-c C-c
Interrupt
- toList (Union (Elems [1,2,34]),(Range {from=6, to=12}));
stdIn:1.9-2.30 Error: operator and operand don't agree [tycon mismatch]
  operator domain: intSet * intSet
  operand:         intSet
  in expression:
    Union (Elems (1 :: 2 :: <exp> :: <exp>))
stdIn:1.2-2.30 Error: operator and operand don't agree [tycon mismatch]
  operator domain: intSet
  operand:         _ * intSet
  in expression:
    toList (Union (Elems (<exp> :: <exp>)),Range {from=6,to=12})
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:266.5-270.47 Warning: match nonexhaustive
          Elems nil => ...
          Elems (x :: xs) => ...
          Range {from=x,to=y} => ...
          Union (x,y) => ...
  
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val toList = fn : intSet -> int list
val it = () : unit
- toList (Union (Elems [1,2,34]),(Range {from=6, to=12}));
stdIn:2.8-2.56 Error: operator and operand don't agree [tycon mismatch]
  operator domain: intSet * intSet
  operand:         intSet
  in expression:
    Union (Elems (1 :: 2 :: <exp> :: <exp>))
stdIn:2.1-2.56 Error: operator and operand don't agree [tycon mismatch]
  operator domain: intSet
  operand:         _ * intSet
  in expression:
    toList (Union (Elems (<exp> :: <exp>)),Range {from=6,to=12})
- toList (Union ((Elems [1,2,34]),(Range {from=6, to=12})));
val it = [1,2,34,6,7,8,9,10,11,12] : int list
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:271.31-271.46 Error: unbound variable or constructor: interOfTwoLists
second_lecture.sml:278.12-278.35 Error: unbound variable or constructor: interToListFromTwoLists
second_lecture.sml:279.9-279.32 Error: unbound variable or constructor: interToListFromTwoLists

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val it = () : unit
- toList (Union ((Elems [1,2,34]),(Range {from=6, to=12})));
val it = [1,2,34,6,7,8,9,10,11,12] : int list
- toList (Intersection ((Elems [1,2,34]),(Range {from=6, to=12})));
val it = [] : int list
- toList (Intersection ((Elems [1,2,34,7,12]),(Range {from=6, to=12})));
val it = [7,12] : int list
- toList (Intersection ((Elems [1,2,34,7,12]),(Range {from=1, to=12})));
val it = [1,2,7,12] : int list
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val it = () : unit
- isEmpty (Intersection ((Elems [1,2,34,7,12]),(Range {from=1, to=12})));
val it = false : bool
- isContains (4, (Intersection ((Elems [1,2,34,7,12]),(Range {from=1, to=12}))));
stdIn:3.1-3.11 Error: unbound variable or constructor: isContains
- iscontains (4, (Intersection ((Elems [1,2,34,7,12]),(Range {from=1, to=12}))));
val it = false : bool
- iscontains (11, (Intersection ((Elems [1,2,34,7,12]),(Range {from=1, to=12}))));
val it = false : bool
- iscontains (12, (Intersection ((Elems [1,2,34,7,12]),(Range {from=1, to=12}))));
val it = true : bool
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:294.5-294.9 Error:can't find function arguments in clause

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val trip = fn : int * int -> int
val it = () : unit
- trip(5,6);
val it = 90 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:294.47-294.51 Error: unbound variable or constructor: trip

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:294.48-294.52 Error: unbound variable or constructor: trip

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:294.23-294.29 Error: unbound varible or constructor: filter

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:294.23-294.29 Error: unbound variable or constructor: filter
uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
[autoloading]
[autoloading done]
second_lecture.sml:279.31-284.12 Error: operator is not a function [tycon mismatch]
  operator: int list
  in expression:
    (interOfTwoLists (toList x,toList y)) List.filter
second_lecture.sml:294.23-294.29 Error: unbound variable or constructor: filter

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val it = () : unit
- all_even_tup [(1,2),(4,3)];
val it = [(1,2)] : (int * int) list
-  ( => , [,,,])
stdIn:3.1 Error: illegal token
stdIn:3.2 Error: illegal token
stdIn:3.3 Error: illegal token
stdIn:3.4 Error: illegal token
stdIn:3.5 Error: illegal token
stdIn:3.6 Error: illegal token
stdIn:3.7 Error: illegal token
stdIn:3.8 Error: illegal token
stdIn:3.9 Error: illegal token
stdIn:3.10 Error: illegal token
stdIn:3.11 Error: illegal token
stdIn:3.12 Error: illegal token
stdIn:3.13 Error: illegal token
stdIn:3.14 Error: illegal token
stdIn:3.15 Error: illegal token
stdIn:3.16 Error: illegal token
stdIn:3.17 Error: illegal token
stdIn:3.18 Error: illegal token
stdIn:3.19 Error: illegal token
stdIn:3.20 Error: illegal token
stdIn:3.21 Error: illegal token
stdIn:3.22 Error: illegal token
stdIn:3.23 Error: illegal token
stdIn:3.24 Error: illegal token
stdIn:3.27 Error: illegal token
stdIn:3.28 Error: illegal token
stdIn:3.29 Error: illegal token
stdIn:3.30 Error: illegal token
stdIn:3.31 Error: illegal token
stdIn:3.32 Error: illegal token
stdIn:3.33 Error: illegal token
stdIn:3.34 Error: illegal token
stdIn:3.36 Error: illegal token
stdIn:3.37 Error: illegal token
stdIn:3.38 Error: illegal token
stdIn:3.39 Error: illegal token
stdIn:3.42 Error: illegal token
stdIn:3.43 Error: illegal token
stdIn:3.44 Error: illegal token
stdIn:3.45 Error: illegal token
stdIn:3.46 Error: illegal token
stdIn:3.47 Error: illegal token
stdIn:3.48 Error: illegal token
stdIn:3.49 Error: illegal token
stdIn:3.50 Error: illegal token
stdIn:3.51 Error: illegal token
stdIn:3.52 Error: illegal token
stdIn:3.53 Error: illegal token
stdIn:3.55 Error: illegal token
stdIn:3.56 Error: illegal token
stdIn:3.57 Error: illegal token
stdIn:3.58 Error: illegal token
stdIn:3.62 Error: illegal token
stdIn:3.63 Error: illegal token
stdIn:3.64 Error: illegal token
stdIn:3.65 Error: illegal token
stdIn:3.66 Error: illegal token
stdIn:3.67 Error: illegal token
stdIn:3.68 Error: illegal token
stdIn:3.69 Error: illegal token
stdIn:3.70 Error: illegal token
stdIn:3.71 Error: illegal token
stdIn:3.72 Error: illegal token
stdIn:3.73 Error: illegal token
stdIn:3.74 Error: illegal token
stdIn:3.75 Error: illegal token
stdIn:3.76 Error: illegal token
stdIn:3.77 Error: illegal token
stdIn:3.40-3.60 Error: syntax error: deleting  DARROW COMMA
stdIn:3.79 Error: illegal token
stdIn:3.80 Error: illegal token
stdIn:3.81 Error: illegal token
stdIn:3.82 Error: illegal token
stdIn:3.83 Error: illegal token
stdIn:3.84 Error: illegal token
stdIn:3.85 Error: illegal token
stdIn:3.86 Error: illegal token
stdIn:3.87 Error: illegal token
stdIn:3.88 Error: illegal token
stdIn:3.89 Error: illegal token
stdIn:3.90 Error: illegal token
stdIn:3.91 Error: illegal token
stdIn:3.92 Error: illegal token
stdIn:3.93 Error: illegal token
stdIn:3.94 Error: illegal token
stdIn:3.95 Error: illegal token
stdIn:3.96 Error: illegal token
stdIn:3.97 Error: illegal token
stdIn:3.98 Error: illegal token
stdIn:3.100 Error: illegal token
stdIn:3.101 Error: illegal token
stdIn:3.102 Error: illegal token
stdIn:3.103 Error: illegal token
stdIn:3.104 Error: illegal token
stdIn:3.105 Error: illegal token
stdIn:3.106 Error: illegal token
stdIn:3.107 Error: illegal token
stdIn:3.108 Error: illegal token
stdIn:3.109 Error: illegal token
stdIn:3.110 Error: illegal token
stdIn:3.111 Error: illegal token
stdIn:3.112 Error: illegal token
stdIn:3.113 Error: illegal token
stdIn:3.114 Error: illegal token
stdIn:3.115 Error: illegal token
stdIn:3.116 Error: illegal token
stdIn:3.117 Error: illegal token
stdIn:3.118 Error: illegal token
stdIn:3.119 Error: illegal token
stdIn:3.121 Error: illegal token
stdIn:3.122 Error: illegal token
stdIn:3.123 Error: illegal token
stdIn:3.124 Error: illegal token
stdIn:3.125 Error: illegal token
stdIn:3.126 Error: illegal token
stdIn:3.127 Error: illegal token
stdIn:3.128 Error: illegal token
stdIn:3.129 Error: illegal token
stdIn:3.130 Error: illegal token
stdIn:3.131 Error: illegal token
stdIn:3.132 Error: illegal token
stdIn:3.133 Error: illegal token
stdIn:3.134 Error: illegal token
stdIn:3.135 Error: illegal token
stdIn:3.136 Error: illegal token
- 
- filter((fn x => not x), [true,false,true, true,false]
= ;
= filter((fn x => not x), [true,false,true, true,false];
stdIn:5.1-6.7 Error: syntax error: deleting  SEMICOLON ID
- ilter((fn x => not x), [true,false,true, true,false];
=   C-c C-c
Interrupt
- filter((fn x => not x), [true,false,true, true,false];
= 
=   C-c C-c
Interrupt
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val it = () : unit
- filter((fn x => not x), [true,false,true, true,false];
= 
=   C-c C-c
Interrupt
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:301.63 Error: syntax error found t SEMICOLON

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:306.10-306.5 Error: operator and operand don't agree [overload conflict]
  operator domain: [+ ty] * [+ ty]
  operand:         exp * [int ty]
  in expression:
    x + 3
second_lecture.sml:307.10-307.15 Error: operator and operand don't agree [overload conflict]
  operator domain: [+ ty] * [+ ty]
  operand:         exp * [int ty]
  in expression:
    x + 4

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val dt = fn : (int -> bool) -> int -> int
val res = fn : int -> int
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val dt = fn : (int -> bool) -> int -> int
val res = fn : int -> int
val e = 7 : int
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val dt = fn : (int -> bool) -> int -> int
val res = fn : int -> int
val e = 7 : int
val x = Add (Constant 19,Negate (Constant 4)) : exp
second_lecture.sml:323.11-323.20 Error: unbound variable or constructor: isAllEven

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val dt = fn : (int -> bool) -> int -> int
val res = fn : int -> int
val e = 7 : int
val x = Add (Constant 19,Negate (Constant 4)) : exp
val isAllEvenExp = fn : exp -> bool
val ans = false : bool
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val dt = fn : (int -> bool) -> int -> int
val res = fn : int -> int
val e = 7 : int
val x = Add (Constant 20,Negate (Constant 4)) : exp
val isAllEvenExp = fn : exp -> bool
val ans = true : bool
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:313.26 Error: unbound variable or constructor: c
second_lecture.sml:313.24-313.29 Error: operator is not a function [overload conflict]
  operator: [int ty]
  in expression:
    11 <errorvar>

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:313.26 Error: unbound variable or constructor: c
second_lecture.sml:313.24-313.29 Error: operator is not a function [overload conflict]
  operator: [int ty]
  in expression:
    11 <errorvar>

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val dt = fn : (int -> bool) -> int -> int
val res = fn : int -> int
val e = 7 : int
val x = Add (Constant 20,Negate (Constant 4)) : exp
second_lecture.sml:315.12-315.17 Error: non-constructor applied to argument in pattern: f
second_lecture.sml:316.10-316.13 Error: unbound variable or constructor: exp
second_lecture.sml:320.27-320.39 Error: unbound variable or constructor: isAllEvenExp
second_lecture.sml:320.50-320.62 Error: unbound variable or constructor: isAllEvenExp
second_lecture.sml:319.22-319.34 Error: unbound variable or constructor: isAllEvenExp
second_lecture.sml:319.45-319.57 Error: unbound variable or constructor: isAllEvenExp
second_lecture.sml:318.21-318.33 Error: unbound variable or constructor: isAllEvenExp
second_lecture.sml:317.16 Error: unbound variable or constructor: f

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val dt = fn : (int -> bool) -> int -> int
val res = fn : int -> int
val e = 7 : int
val x = Add (Constant 20,Negate (Constant 4)) : exp
second_lecture.sml:320.27-320.39 Error: unbound variable or constructor: isAllEvenExp
second_lecture.sml:320.50-320.62 Error: unbound variable or constructor: isAllEvenExp
second_lecture.sml:319.22-319.34 Error: unbound variable or constructor: isAllEvenExp
second_lecture.sml:319.45-319.57 Error: unbound variable or constructor: isAllEvenExp
second_lecture.sml:318.21-318.33 Error: unbound variable or constructor: isAllEvenExp

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val dt = fn : (int -> bool) -> int -> int
val res = fn : int -> int
val e = 7 : int
val x = Add (Constant 20,Negate (Constant 4)) : exp
second_lecture.sml:318.21-318.28 Error: operator nd operand don't agree [tycon mismatch]
  operator domain: (int -> 'Z) * 'Y
  operand:         exp
  in expression:
    isAll i
second_lecture.sml:319.22-319.29 Error: operator and operand don't agree [tycon mismatch]
  operator domain: (int -> _) * 'Z
  operand:         exp
  in expression:
    isAll a
second_lecture.sml:319.38-319.45 Error: operator and operand don't agree [tycon mismatch]
  operator domain: (int -> _) * 'Z
  operand:         exp
  in expression:
    isAll b
second_lecture.sml:320.27-320.34 Error: operator and operand don't agree [tycon mismatch]
  operator domain: (int -> _) * 'Z
  operand:         exp
  in expression:
    isAll a
second_lecture.sml:320.43-320.50 Error: operator and operand don't agree [tycon mismatch]
  operator domain: (int -> _) * 'Z
  operand:         exp
  in expression:
    isAll b

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val dt = fn : (int -> bool) -> int -> int
val res = fn : int -> int
val e = 7 : int
val x = Add (Constant 20,Negate (Constant 4)) : exp
val isAll = fn : (int -> bool) * exp -> bool
val ans = true : bool
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val dt = fn : (int -> bool) -> int -> int
val res = fn : int -> int
val e = 7 : int
val x = Add (Constant 20,Negate (Constant 3)) : exp
val isAll = fn : (int -> bool) * exp -> bool
val ans = false : bool
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val dt = fn : (int -> bool) -> int -> int
val res = fn : int -> int
val e = 7 : int
val x = Add (Constant 20,Negate (Constant 3)) : exp
val isAll = fn : (int -> bool) * exp -> bool
val ans = false : bool
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val dt = fn : (int -> bool) -> int -> int
val res = fn : int -> int
val e = 7 : int
val x = Add (Constant 20,Negate (Constant 3)) : exp
val isAll = fn : (int -> bool) * exp -> bool
val ans = true : bool
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val dt = fn : (int -> bool) -> int -> int
val res = fn : int -> int
val e = 7 : int
val x = Add (Constant 20,Negate (Constant 3)) : exp
val isAll = fn : (int -> bool) * exp -> bool
val ans = true : bool
val f = fn : int -> int
val g = fn : int -> int
val compose = fn : ('a -> 'b) * ('c -> 'a) -> 'c -> 'b
second_lecture.sml:331.5-331.23 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int
  operand:         exp
  in expression:
    (compose (f,g)) x

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val dt = fn : (int -> bool) -> int -> int
val res = fn : int -> int
val e = 7 : int
val x = Add (Constant 20,Negate (Constant 3)) : exp
val isAll = fn : (int -> bool) * exp -> bool
val ans = true : bool
val f = fn : int -> int
val g = fn : int -> int
val compose = fn : ('a -> 'b) * ('c -> 'a) -> 'c -> 'b
val z = 10 : int
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val dt = fn : (int -> bool) -> int -> int
val res = fn : int -> int
val e = 7 : int
val x = Add (Constant 20,Negate (Constant 3)) : exp
val isAll = fn : (int -> bool) * exp -> bool
val ans = true : bool
val f = fn : int -> int
val g = fn : int -> int
val compose = fn : ('a -> 'b) * ('c -> 'a) -> 'c -> 'b
val z = 10 : int
val g = fn : int -> int
val z = 11 : int
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val dt = fn : (int -> bool) -> int -> int
val res = fn : int -> int
val e = 7 : int
val x = Add (Constant 20,Negate (Constant 3)) : exp
val isAll = fn : (int -> bool) * exp -> bool
val ans = true : bool
val f = fn : int -> int
val g = fn : int -> int
val compose = fn : ('a -> 'b) * ('c -> 'a) -> 'c -> 'b
second_lecture.sml:331.5-331.27 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int
  operand:         [int ty] * [int ty]
  in expression:
    (compose (f,g)) (1,2)

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "second_lecture.sml";
[opening second_lecture.sml]
datatype exp
  = Add of exp * exp | Constant of int | Multiply of exp * exp | Negate of exp
val x = Add (Constant 19,Negate (Constant 4)) : exp
val eval = fn : exp -> int
val it = 15 : int
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
second_lecture.sml:33.5-35.73 Warning: match nonexhaustive
          (nil,nil,nil) => ...
          (hd1 :: tl1,hd2 :: tl2,hd3 :: tl3) => ...
  
val max = fn : exp -> int
val zip3 = fn : 'a list * 'b list * 'c list -> ('a * 'b * 'c) list
val zip3rev = fn : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val nondec = fn : int list -> bool
datatype sgn = N | P | Z
val multsign = fn : sgn * sgn -> sgn
val append = fn : 'a list * 'a list -> 'a list
val rev = fn : 'a list -> 'a list
val rrev = fn : 'a list -> 'a list
datatype 'a mylist = Empty | Value of 'a * 'a mylist
val ml = Value (5,Empty) : int mylist
val ml2 = Value (5,Value (4,Empty)) : int mylist
type student_id = int
type grade = int
type final_grade = {grade:grade option, id:student_id}
datatype pass_fail = fail | pass
val pass_fail = fn : {grade:int option, id:'a} -> pass_fail
val has_p = fn : {grade:int option, id:'a} -> bool
val num_p = fn : {grade:int option, id:'a} list -> int
val lofg =
  [{grade=NONE,id=5},{grade=SOME 80,id=5},{grade=SOME 40,id=5},
   {grade=SOME 90,id=5}] : {grade:int option, id:int} list
val mis =
  [(pass,{grade=NONE,id=5}),(pass,{grade=SOME 80,id=5}),
   (pass,{grade=SOME 40,id=5}),(pass,{grade=SOME 90,id=5})]
  : (pass_fail * {grade:int option, id:int}) list
val num_m = fn : (pass_fail * {grade:int option, id:'a}) list -> int
datatype 'a tree = leaf | node of {left:'a tree, right:'a tree, value:'a}
datatype flag = lma | pm
val t1 = leaf : 'a tree
val t2 =
  node {left=leaf,right=node {left=node #,right=node #,value=lma},value=lma}
  : flag tree
val tree_h = fn : 'a tree -> int
val tree_sum = fn : int tree -> int
val garden = fn : flag tree -> flag tree
val mylast = fn : int list -> int
val mytake = fn : int list * int -> int list
val it = [] : int list
val it = [1,3,2] : int list
val it = [1,3,2,4] : int list
val it = [1,3,2,4,98] : int list
val it = [98] : int list
val mydrop = fn : int list * int -> int list
val it = [1,3,2,4] : int list
val it = [4] : int list
val it = [] : int list
val it = [99] : int list
val it = [99] : int list
val myconcat = fn : 'a list list -> 'a list
datatype nat = SUCC of nat | ZERO
val pos = fn : nat -> bool
val it = false : bool
val it = true : bool
val it = true : bool
val s1 = ZERO : nat
exception Negative of string
val pred = fn : nat -> nat
val n0 = ZERO : nat
val n1 = SUCC ZERO : nat
val n2 = SUCC (SUCC ZERO) : nat
val n3 = SUCC (SUCC (SUCC ZERO)) : nat
second_lecture.sml:262.23 Warning: calling polyEqual
val nat_to_int = fn : nat -> int
val add = fn : nat * nat -> nat
val sub = fn : nat * nat -> nat
val mult = fn : nat * nat -> nat
val less_than = fn : nat * nat -> bool
datatype intSet
  = Elems of int list
  | Intersection of intSet * intSet
  | Range of {from:int, to:int}
  | Union of intSet * intSet
val listContains = fn : ''a * ''a list -> bool
val interOfTwoLists = fn : ''a list * ''a list -> ''a list
val toList = fn : intSet -> int list
val iscontains = fn : int * intSet -> bool
val isEmpty = fn : intSet -> bool
val filter = fn : ('a -> bool) * 'a list -> 'a list
val all_even_tup = fn : ('a * int) list -> ('a * int) list
val ok = [false,false] : bool list
val dt = fn : (int -> bool) -> int -> int
val res = fn : int -> int
val e = 7 : int
val x = Add (Constant 20,Negate (Constant 3)) : exp
val isAll = fn : (int -> bool) * exp -> bool
val ans = true : bool
val f = fn : int -> int
val g = fn : int -> int
second_lecture.sml:330.13-331.27 Error: types of rules don't agree [circularity]
  earlier rule(s): 'Z -> 'Y
  this rule: 'Z -> 'X -> 'Y
  in rule:
    x => (fn x => f x)
second_lecture.sml:329.21-331.27 Error: case object and rules don't agree [tycon mismatch]
  rule domain: 'Z * 'Y
  object: exp
  in expression:
    (case x
      of (_,x) => (fn x => f <exp>
                    | x => (fn <rule>)))

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "week_4_extra_ptoblems.sml";
[opening week_4_extra_ptoblems.sml]
[use failed: Io: openIn failed on "week_4_extra_ptoblems.sml", No such file or directory]

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/interact.sml:24.14-24.28
- use "week_4_extra_problems.sml";
[opening week_4_extra_problems.sml]
val compose_opt = fn
  : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option
val it = () : unit
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "week_4_extra_problems.sml";
[opening week_4_extra_problems.sml]
week_4_extra_problems.sml:9.7-9.9 Erro: infix operator "!>" used without "op" in fun dec
week_4_extra_problems.sml:9.12-9.14 Error: infix operator "!>" used without "op" in fun dec
week_4_extra_problems.sml:9.5-9.25 Error: duplicate variable in pattern(s): !>
week_4_extra_problems.sml:9.5-9.25 Error: right-hand-side of clause doesn't agree with function result type [circularity]
  expression:  (('Z -> 'Y) -> 'X) -> 'W -> ('X -> 'V) -> 'V
  result type:  'Y
  in declaration:
    x = (fn arg => (fn <pat> => <exp>))
week_4_extra_problems.sml:11.43-11.45 Error: unbound variable or constructor: !>
week_4_extra_problems.sml:11.38-11.40 Error: unbound variable or constructor: !>

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "week_4_extra_problems.sml";
[opening week_4_extra_problems.sml]
val compose_opt = fn
  : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option
val do_until = fn : ('a -> 'a) * ('a -> bool) -> 'a -> 'a
val it = () : unit
- do_until (fn x => x div 2) (fn y => y mod 2 = 0) 30;
stdIn:2.1-2.52 Error: operator and operand don't agree [tycon mismatch]
  operator domain: ('Z -> 'Z) * ('Z -> bool)
  operand:         [div ty] -> [div ty]
  in expression:
    do_until (fn x => x div 2)
- do_until ((fn x => x div 2) (fn y => y mod 2 = 0)) 30;
stdIn:1.12-2.17 Error: operator and operand don't agree [overload conflict]
  operator domain: [div ty]
  operand:         [mod ty] -> bool
  in expression:
    (fn x => x div 2) (fn y => <exp> mod <exp> = 0)
- val p = do_until ((fn x => x div 2) (fn y => y mod 2 = 0));
stdIn:1.20-2.25 Error: operator and operand don't agree [overload conflict]
  operator domain: [div ty]
  operand:         [mod ty] -> bool
  in expression:
    (fn x => x div 2) (fn y => <exp> mod <exp> = 0)
- val p = do_until ((fn x => x div 2) (fn y => y mod 2 <> 0));
stdIn:1.20-2.26 Error: operator and operand don't agree [overload conflict]
  operator domain: [div ty]
  operand:         [mod ty] -> bool
  in expression:
    (fn x => x div 2) (fn y => <exp> mod <exp> <> 0)
- val p = do_until ((fn x => x div 2), (fn y => y mod 2 <> 0));
val p = fn : int -> int
- p 30;
val it = 0 : int
- val p = do_until ((fn x => x div 2), (fn y => y mod 2 = 0));
val p = fn : int -> int
- p 30;
val it = 15 : int
- p 100;
val it = 25 : int
- p 64;
val it = 1 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- 
- use "week_4_extra_problems.sml";
[opening week_4_extra_problems.sml]
val compose_opt = fn
  : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option
val do_until = fn : ('a -> 'a) * ('a -> bool) -> 'a -> 'a
week_4_extra_problems.sml:17.19-17.26 Error: unbound variable orconstructor: do_fact

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "week_4_extra_problems.sml";
[opening week_4_extra_problems.sml]
val compose_opt = fn
  : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option
val do_until = fn : ('a -> 'a) * ('a -> bool) -> 'a -> 'a
week_4_extra_problems.sml:15.5-18.20 Error: right-hand-side of clause doesn't agree with function result type [overload conflict]
  expression:  [int ty] -> [int ty]
  result type:  [int ty]
  in declaration:
    do_fact = (fn x => do_until (<exp>,<exp>))

uncaught exception Error
  raised at: ../compiler/TopLevel/interact/evalloop.sml:66.19-66.27
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "week_4_extra_problems.sml";
[opening week_4_extra_problems.sml]
val compose_opt = fn
  : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option
val do_until = fn : ('a -> 'a) * ('a -> bool) -> 'a -> 'a
val do_fact = fn : int -> int
val it = () : unit
- do_fact 3;
  C-c C-c
Interrupt
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "week_4_extra_problems.sml";
[opening week_4_extra_problems.sml]
val compose_opt = fn
  : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option
val do_until = fn : ('a -> 'a) * ('a -> bool) -> 'a -> 'a
val do_fact = fn : int -> int
val it = () : unit
- do_fact 3;
  C-c C-c
Interrupt
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "week_4_extra_problems.sml";
[opening week_4_extra_problems.sml]
val compose_opt = fn
  : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option
val do_until = fn : ('a -> 'a) * ('a -> bool) -> 'a -> 'a
week_4_extra_problems.sml:15.41 Error: syntax error: insertig  LPAREN

uncaught exception Compile [Compile: "syntax error"]
  raised at: ../compiler/Parse/main/smlfile.sml:15.24-15.46
             ../compiler/TopLevel/interact/evalloop.sml:44.55
             ../compiler/TopLevel/interact/evalloop.sml:292.17-292.20
- use "week_4_extra_problems.sml";
[opening week_4_extra_problems.sml]
val compose_opt = fn
  : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option
val do_until = fn : ('a -> 'a) * ('a -> bool) -> 'a -> 'a
val do_fact = fn : int -> int
val it = () : unit
- do_fact 3;
val it = 6 : int
- do_fact 1;
val it = 0 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "week_4_extra_problems.sml";
[opening week_4_extra_problems.sml]
val compose_opt = fn
  : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option
val do_until = fn : ('a -> 'a) * ('a -> bool) -> 'a -> 'a
val do_fact = fn : int -> int
val it = () : unit
- do_fact 1;
val it = ~1 : int
- do_fact 3;
val it = 6 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "week_4_extra_problems.sml";
[opening week_4_extra_problems.sml]
val compose_opt = fn
  : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option
val do_until = fn : ('a -> 'a) * ('a -> bool) -> 'a -> 'a
val do_fact = fn : int -> int
val it = () : unit
- do_fact 3;
val it = 3 : int
- do_fact 1;
val it = 0 : int
- do_fact 4;
val it = 12 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "week_4_extra_problems.sml";
[opening week_4_extra_problems.sml]
val compose_opt = fn
  : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option
val do_until = fn : ('a -> 'a) * ('a -> bool) -> 'a -> 'a
val do_fact = fn : int -> int
val it = () : unit
- do_fact 4;
val it = 12 : int
- do_fact 1;
  C-c C-c
Interrupt
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "week_4_extra_problems.sml";
[opening week_4_extra_problems.sml]
val compose_opt = fn
  : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option
val do_until = fn : ('a -> 'a) * ('a -> bool) -> 'a -> 'a
val do_fact = fn : int -> int
val it = () : unit
- do_fact 1;
val it = 1 : int
- do_fact 4;
val it = 12 : int
- do_fact 0;
  C-c C-c
Interrupt
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "week_4_extra_problems.sml";
[opening week_4_extra_problems.sml]
val compose_opt = fn
  : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option
val do_until = fn : ('a -> 'a) * ('a -> bool) -> 'a -> 'a
val do_fact = fn : int -> int
val it = () : unit
- do_fact 0;

uncaught exception Overflow [overflow]
  raised at: <file week_4_extra_problems.sml>
- do_fact 4;
val it = 12 : int
- do_fact 3;
val it = 6 : int
- do_fact 2;
val it = 2 : int
-   C-c C-c
Interrupt
- do_fact 5;
val it = 20 : int
- 

Process sml finished
Standard ML of New Jersey v110.79 [built: Sun Oct  4 14:45:06 2015]
- use "week_4_extra_problems.sml";
[opening week_4_extra_problems.sml]
val compose_opt = fn
  : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option
val do_until = fn : ('a -> 'a) * ('a -> bool) -> 'a -> 'a
val do_fact = fn : int -> int
val it = () : unit
- do_fact 5;
